#!/usr/bin/perl -w

use lib '.';
use Lingua::TT;
use Lingua::TT::Diff;

use Getopt::Long qw(:config no_ignore_case);
use Pod::Usage;
use File::Basename qw(basename);


##----------------------------------------------------------------------
## Globals
##----------------------------------------------------------------------

our $VERSION = "0.01";

##-- program vars
our $progname     = basename($0);
our $verbose      = 1;

our $outfile      = '-';
our %diffargs     = qw();

##----------------------------------------------------------------------
## Command-line processing
##----------------------------------------------------------------------
GetOptions(##-- general
	   'help|h' => \$help,
	   'man|m'  => \$man,
	   'version|V' => \$version,
	   'verbose|v=i' => \$verbose,

	   ##-- I/O
	   'output|o=s' => \$outfile,
	  );

pod2usage({-exitval=>0,-verbose=>0}) if ($help);
pod2usage({-exitval=>0,-verbose=>1}) if ($man);
#pod2usage({-exitval=>0,-verbose=>1,-msg=>'Not enough arguments specified!'}) if (@ARGV < 2);

if ($version || $verbose >= 2) {
  print STDERR "$progname version $VERSION by Bryan Jurish\n";
  exit 0 if ($version);
}

##----------------------------------------------------------------------
## subs

## $max1 = hunk_max1($hunk)
##   + not suitable for range
sub hunk_max1 {
  return $_->[2] > $_->[1] ? $_->[2] : $_->[1];
}

## $max2 = hunk_max2($hunk)
##   + not suitable for range
sub hunk_max2 {
  return $_->[4] > $_->[3] ? $_->[4] : $_->[3];
}

##----------------------------------------------------------------------
## MAIN
##----------------------------------------------------------------------
push(@ARGV,'-') if (!@ARGV);

our $diff = Lingua::TT::Diff->new(%diffargs);
our $dfile = shift(@ARGV);
$diff->loadTextFile($dfile)
  or die("$0: load failed from '$dfile': $!");

##-- common vars
my ($seq1,$seq2,$hunks) = @$diff{qw(seq1 seq2 hunks)};
my ($op,$min1,$max1,$min2,$max2,$fix);
my (@items1,@items2);

##--------------------------------------------------------------
## MAIN: split hunks into single-line add or delete
my $hunks_old = $hunks;
my $hunks_new =[
		 map {
		   ($op,$min1,$max1,$min2,$max2, $fix) = @$_;
		   ($fix
		    ? ($_)
		    : (
		       (map {['d',$_,$_,$min2,($min2-1)]} ($min1..$max1)),
		       (map {['a',$min1,($min1-1),$_,$_]} ($min2..$max2)),
		      ))
		 } @$hunks_old
		];
@$hunks_new = sort {
  (0
   || ($a->[2]>$a->[1] ? $a->[2] : $a->[1]) <=> ($b->[2]>$b->[1] ? $b->[2] : $b->[1])
   || ($a->[4]>$a->[3] ? $a->[4] : $a->[3]) <=> ($b->[4]>$b->[3] ? $b->[4] : $b->[3])
   ##--
   ##|| $a->[1] <=> $b->[1]
   #|| $a->[2] <=> $b->[2]
   ##|| $a->[3] <=> $b->[3]
   #|| $a->[4] <=> $b->[4]
   ##--
   || $b->[0] cmp $a->[0])
} @$hunks_new;
$hunks = $diff->{hunks} = $hunks_new;


##--------------------------------------------------------------
## MAIN: Heuristics: Simple: EOS, comments
my ($item1,$item2, $i1,$i2);
foreach $hunk (@$hunks) {
  ($op,$min1,$max1,$min2,$max2, $fix) = @$hunk;
  next if ($fix); ##-- already resolved
  $i1 = $min1;
  $i2 = $min2;
  $item1 = $min1 <= $max1 ? $seq1->[$min1] : undef;
  $item2 = $min2 <= $max2 ? $seq2->[$min2] : undef;

  ##-- DELETE: $1 ~ cmt|eos -> $1
  if ($op eq 'd' && $item1=~/^(?:\%\%|$)/)
    {
      $hunk->[5] = 1;
    }
  ##-- INSERT: $2 ~ cmt|eos -> $1
  elsif ($op eq 'a' && $item2=~/^(?:\%\%|$)/)
    {
      $hunk->[5] = 1;
    }
  ##-- DELETE: $1 ~ "''"@eos -> $1
  elsif ($op eq 'd' && $item1=~/^\'\'\t/ && ($i1==$#$seq1 || $seq1->[$i1+1]=~/^$/))
    {
      $hunk->[5] = 1;
    }
  ##-- INSERT: $2 ~ "''"@bos -> $1
  elsif ($op eq 'a' && $item2=~/^\'\'(?:\t|$)/ && ($i2==0 || $seq2->[$i2-1]=~/^$/))
    {
      $hunk->[5] = 1;
    }
}

##--------------------------------------------------------------
## MAIN: collect hunks
my $hunks_newer =[];
my ($hi,$hj, @ops,$hunki,$hunkj, $fixi,$fixj);
for ($hi=0; $hi <= $#$hunks; $hi++) {
  $hunki = $hunks->[$hi];
  $fixi  = defined($hunki->[5]) ? $hunki->[5] : ($hunki->[5]=0);

  ##-- set initial output $hunk
  $hunk  = [@$hunki];

  ##-- find end of run
  for ($hj=$hi+1; $hj <= $#$hunks; $hj++) {
    $hunkj = $hunks->[$hj];
    $fixj  = defined($hunkj->[5]) ? $hunkj->[5] : ($hunkj->[5]=0);
    last if (
	     ($fixj ne $fixi)                 ##-- fix-mismatch
	     || ($hunkj->[1]-$hunk->[2] > 1)  ##-- discontinuous on seq1
	     || ($hunkj->[3]-$hunk->[4] > 1)  ##-- discontinuous on seq2
	    );
    ##-- promote output $hunk
    $hunk->[0] = 'c'         if ($hunk->[0] ne $hunkj->[0]);
    $hunk->[2] = $hunkj->[2] if ($hunkj->[2] > $hunk->[2]);
    $hunk->[4] = $hunkj->[4] if ($hunkj->[4] > $hunk->[4]);
  }

  ##-- update
  push(@$hunks_newer,$hunk);
  $hi=$hj-1;
}
$hunks = $diff->{hunks} = $hunks_newer;

##--------------------------------------------------------------
## MAIN: heuristics: on collected hunks
foreach $hunk (@$hunks) {
  ($op,$min1,$max1,$min2,$max2, $fix) = @$hunk;
  next if ($fix); ##-- already fixed
  @items1 = @$seq1[$min1..$max1];
  @items2 = @$seq2[$min2..$max2];

  ##-- CHANGE: Numeric Grouping: $1 ~ /CARD+/ & $2 ~ /CARD/ -> $2
  if ($op eq 'c'
      && @items1==(grep {/^\d+\tCARD$/} @items1)
      && @items2==1
      && $items2[0] =~ /^\d[\d\_]+(?:\t.*)?\tCARD(?:\t|$)/)
    {
      $item2 = $items2[0];
      $item2 =~ s/\t.*//;
      $hunk->[5] = ["$item2\tCARD"];
    }
  ##-- CHANGE: Dates: $1 ~ (... (NN|CARD)) & $2 ~ DATE -> text($2).("=" tag($1)).analyses($2)
  elsif ($op eq 'c'
	 && @items2==1
	 && $items2[0] =~ /\t\$DATE(?:\t|$)/
	 && $items1[$#items1] =~ /\t(?:NN|CARD)$/)
    {
      $tag1 = $items1[$#items1];   $tag1  =~ s/^.*\t//;
      $txt2 = $items2[0];          $txt2  =~ s/\t.*//;
      $anl2 = $items2[0];          $anl2  =~ s/^[^\t]*\t//;
      $hunk->[5] = [$txt2."\t".'='.$tag1."\t".$anl2];
    }
  ##-- CHANGE: Abbrs: $1 ~ (*/* ./$.) & $2 ~ (*./XY,$ABBREV) -> $1
  elsif ($op eq 'c'
	 && @items1==2
	 && $items1[1] =~ /^\.\t/
	 && @items2==1
	 && $items2[0] =~ /\t\$ABBREV/)
    {
      $hunk->[5] = 1;
    }
  ##-- CHANGE: Numeric breaks: $1 ~ (*[[:digit:]]*/*) & $2 ~ (...) -> $1
  elsif ($op eq 'c'
	 && @items1==1
	 && $items1[0] =~ /^[^\t]*\d/)
    {
      $hunk->[5] = 1;
    }
  ##-- CHANGE: Punctuation breaks: $1 ~ (*[[:punct:]]*/*) & $2 ~ (...) -> $1
  elsif ($op eq 'c'
	 && @items1==1
	 && $items1[0] =~ /^[^\t]*[[:punct:]]/)
    {
      $hunk->[5] = 1;
    }
  ##-- CHANGE: MWE (NE): $1 ~ (*/NE)+ & $2 ~ (*_*/-) -> text($2) "=NE"
  elsif ($op eq 'c'
	 && @items1==(grep {/\tNE$/} @items1)
	 && @items2==1
	 && $items2[0] =~ /^[[:alpha:]\_]+$/)
    {
      $hunk->[5] = [$items2[0]."\t=NE"];
    }
  ##-- CHANGE: MWE (FM): $1 ~ (*/FM)+ & $2 ~ (*_*/-) -> text($2) "=FM"
  elsif ($op eq 'c'
	 && @items1==(grep {/\tFM$/} @items1)
	 && @items2==1
	 && $items2[0] =~ /^[[:alpha:]\_]+$/)
    {
      $hunk->[5] = [$items2[0]."\t=FM"];
    }
  ##-- CHANGE: MWE (ADJ NN): $1 ~ (*/ADJ* */NN)+ & $2 ~ (*_*/-) -> text($2) "=NN"
  elsif ($op eq 'c'
	 && @items1==2
	 && $items1[0] =~ /\tADJ/
	 && $items1[1] =~ /\tNN$/
	 && @items2==1
	 && $items2[0] =~ /^[[:alpha:]\_]+$/)
    {
      $hunk->[5] = [$items2[0]."\t=NN"];
    }
  ##-- CHANGE: MWE (NN ART NN): $1 ~ (*/NN */ART */NN)+ & $2 ~ (*_*/-) -> text($2) "=NN"
  elsif ($op eq 'c'
	 && @items1==3
	 && $items1[0] =~ /\tNN$/
	 && $items1[1] =~ /\tART$/
	 && $items1[2] =~ /\tNN$/
	 && @items2==1
	 && $items2[0] =~ /^[[:alpha:]\_]+$/)
    {
      $hunk->[5] = [$items2[0]."\t=NN"];
    }
  ##-- CHANGE: MWE (NE NN): $1 ~ (*/NE */NN)+ & $2 ~ (*_*/-) -> text($2) "=NE"
  elsif ($op eq 'c'
	 && @items1==2
	 && $items1[0] =~ /\tNE$/
	 && $items1[1] =~ /\tNN$/
	 && @items2==1
	 && $items2[0] =~ /^[[:alpha:]\_]+$/)
    {
      $hunk->[5] = [$items2[0]."\t=NE"];
    }
}




##--------------------------------------------------------------
## MAIN: save
$diff->saveTextFile($outfile)
  or die("$0: save failed to '$outfile': $!");


__END__

###############################################################
## pods
###############################################################

=pod

=head1 NAME

tt-tiger-diff-auto.perl - heuristically resolve some conflicts in TIGER - ToMaSoTaTh tt-diffs

=head1 SYNOPSIS

 tt-tiger-diff-auto.perl OPTIONS [TT_DIFF_FILE=-]

 General Options:
   -help
   -version
   -verbose LEVEL

 Other Options:
   -output FILE         ##-- output file (default: STDOUT)

=cut

###############################################################
## OPTIONS
###############################################################
=pod

=head1 OPTIONS

=cut

###############################################################
# General Options
###############################################################
=pod

=head2 General Options

=over 4

=item -help

Display a brief help message and exit.

=item -version

Display version information and exit.

=item -verbose LEVEL

Set verbosity level to LEVEL.  Default=1.

=back

=cut


###############################################################
# Other Options
###############################################################
=pod

=head2 Other Options

=over 4

=item -someoptions ARG

Example option.

=back

=cut


###############################################################
# Bugs and Limitations
###############################################################
=pod

=head1 BUGS AND LIMITATIONS

Probably many.

=cut


###############################################################
# Footer
###############################################################
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head1 SEE ALSO

perl(1).

=cut
