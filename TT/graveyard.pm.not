## -*- Mode: CPerl -*-

##--------------------------------------------------------------
## Lingua::TT::Document.pm
## Methods: I/O: Binary

our ($BIN_MAGIC);
BEGIN {
  $BIN_MAGIC = __PACKAGE__ . "\n";
}

## $doc = $doc->toBinFile($filename_or_fh,%opts)
##  + %opts:
##     encoding => $enc,  ##-- output encoding (default='UTF-8')
sub toBinFile {
  my ($doc,$file,%opts) = @_;
  %opts = (encoding=>'UTF-8',%opts);
  my $fh = ref($file) ? $file : IO::File->new(">$file");
  confess(ref($doc)."::toBinFile(): open failed for file '$file': $!") if (!$fh);

  ##-- construct indices
  my $siv = ''; ##-- [$si] -> buffer-index of sentence $si start
  my $tiv = ''; ##-- [$ti] -> buffer-index of token $ti start
  #my $wiv = ''; ##-- [$wi] -> buffer-index of vanilla-token $wi start
  my $buf = ''; ##-- raw text buffer

  my ($s,$t);
  my ($si,$ti,$wi) = (0,0,0);
  foreach $s (@$doc) {
    vec($siv,$si++,32) = length($buf);
    foreach $t (@$s) {
      vec($tiv,$ti++,32) = length($buf);
      #vec($wiv,$wi++,32) = length($buf) if ($t->isVanilla);
      $buf .= encode($opts{encoding},join("\t",@$t));
    }
  }
  ##-- append final indices
  vec($siv,($#$doc+1),32) = length($buf);
  vec($tiv,$ti,32) = length($buf);
  #vec($wiv,$wi,32) = length($buf);

  ##-- dump data to filehandle
  $fh->print($BIN_MAGIC,
	     #pack('NNNN', $#$doc+2, $ti+1, $wi+1, length($buf)),
	     pack('NNN', $#$doc+2, $ti+1, length($buf)),
	     $siv,
	     $tiv,
	     $buf,
	    );

  $fh->close if (!ref($file));
  return $doc;
}

## $doc = $class_or_obj->fromBinFile($filename_or_fh,%opts)
##  + %opts:
##     encoding => $enc,  ##-- input encoding (default='UTF-8')
sub fromBinFile {
  my ($doc,$file,%opts) = @_;
  $doc = $doc->new if (!ref($doc));
  %opts = (encoding=>'UTF-8',%opts);
  my $fh = ref($file) ? $file : IO::File->new("<$file");
  confess(ref($doc)."::fromBinFile(): open failed for file '$file': $!") if (!$fh);
  @$doc = qw();

  ##-- read handle
  my $magic = <$fh>;
  confess(ref($doc)."::fromBinFile(): bad magic in file '$file': $!") if ($magic ne $BIN_MAGIC);
  my $hdr='';
  read($fh,$hdr,12);
  my ($nsents,$ntoks,$buflen) = unpack('NNN',$hdr);
  my $siv='';
  read($fh,$siv,$nsents*4);
  my $tiv='';
  read($fh,$tiv,$ntoks*4);
  my $buf='';
  read($fh,$buf,$buflen);

  ##-- decode buffer
  my ($si,$s, $sbi0,$sbi1);
  my ($ti,$tbi0,$tbi1) = (0,0,0);
  foreach $si (0..($nsents-1)) {
    $sbi0 = vec($siv,$si,  32);
    $sbi1 = vec($siv,$si+1,32);
    push(@$doc, $s=bless([],'Lingua::TT::Sentence'));
    for ( ; $tbi0 < $sbi1; $ti++,$tbi0=$tbi1) {
      $tbi1 = vec($tiv,$ti+1,32);
      push(@$s,bless([split(/\t/,decode($opts{encoding},substr($buf,$tbi0,$tbi1-$tbi0)))],'Lingua::TT::Token'));
    }
  }

  $fh->close if (!ref($file));
  return $doc;
}
